@page "/game"
@rendermode InteractiveWebAssembly
@using System.Threading
@using Microsoft.AspNetCore.Components.Web
@using Blazor.Extensions
@using Blazor.Extensions.Canvas
@using Blazor.Extensions.Canvas.Canvas2D

<DxToolbar>
    <Items>
        <DxToolbarItem Text="Başlat" Click="StartGame" />
        <DxToolbarItem Text="Durdur" Click="StopGame" />
        <DxToolbarItem Text="Yeniden Başlat" Click="RestartGame" />
        <DxToolbarItem Text="@($"Skor: {Score}")" />
    </Items>
</DxToolbar>

<div tabindex="0"
     style="outline:none; display:inline-block; border:1px solid #e0e0e0; width:420px; height:640px;"
     @onkeydown="HandleKeyDown"
     @onpointerdown="HandlePointerDown">
    <BECanvas Width="420" Height="640"
              @ref="canvas">
    </BECanvas>
</div>

@code {
    private BECanvasComponent? canvas;
    private Canvas2DContext? ctx;

    private readonly Random rng = new();
    private bool isRunning;
    private PeriodicTimer? loopTimer;

    private double birdY;
    private double birdVelocityY;
    private double gravityPerTick = 0.5;
    private double jumpImpulse = -8;

    private double pipeX;
    private double pipeGapTop;
    private double pipeGapSize = 140;
    private double pipeSpeed = 2.8;

    public int Score { get; set; }
    private bool canScoreCurrentPair;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        ctx = await canvas!.CreateCanvas2DAsync();
        await ResetSceneAsync();
        await StartGame();
    }

    private async Task ResetSceneAsync()
    {
        isRunning = false;
        loopTimer?.Dispose();

        Score = 0;
        birdY = 150;
        birdVelocityY = 0;

        pipeX = 420 + 20;
        pipeGapTop = 100 + rng.Next(0, 140);
        canScoreCurrentPair = true;

        if (ctx != null) await DrawAsync();
        StateHasChanged();
    }

    private async Task StartGame()
    {
        if (isRunning || ctx == null) return;
        isRunning = true;
        loopTimer = new PeriodicTimer(TimeSpan.FromMilliseconds(16));
        _ = GameLoopAsync(loopTimer);
    }

    private async Task StopGame()
    {
        isRunning = false;
        loopTimer?.Dispose();
        await InvokeAsync(StateHasChanged);
    }

    private async Task RestartGame()
    {
        await ResetSceneAsync();
        await StartGame();
    }

    private async Task GameLoopAsync(PeriodicTimer timer)
    {
        while (isRunning && await timer.WaitForNextTickAsync())
        {
            UpdatePhysics();
            await DrawAsync();
            if (IsGameOver()) await StopGame();
        }
    }

    private void UpdatePhysics()
    {
        birdVelocityY += gravityPerTick;
        birdY += birdVelocityY;

        pipeX -= pipeSpeed;
        if (pipeX < -60)
        {
            pipeX = 420 + 20;
            pipeGapTop = 80 + rng.Next(0, 160);
            canScoreCurrentPair = true;
        }

        if (canScoreCurrentPair && (80 > pipeX + 60))
        {
            Score++;
            canScoreCurrentPair = false;
        }
    }

    private bool IsGameOver()
    {
        if (birdY < 0 || birdY > 640) return true;

        var bird = new Rect(80, birdY, 34, 24);
        var top  = new Rect(pipeX, 0, 60, pipeGapTop);
        var bot  = new Rect(pipeX, pipeGapTop + pipeGapSize, 60, 640 - (pipeGapTop + pipeGapSize));
        return bird.Intersects(top) || bird.Intersects(bot);
    }

    private async Task DrawAsync()
    {
        if (ctx == null) return;

        await ctx.ClearRectAsync(0, 0, 420, 640);
        // Sky background for visibility
        await ctx.SetFillStyleAsync("#87CEEB");
        await ctx.FillRectAsync(0, 0, 420, 640);

        await ctx.SetFillStyleAsync("#4caf50");
        await ctx.FillRectAsync(pipeX, 0, 60, pipeGapTop);
        await ctx.FillRectAsync(pipeX, pipeGapTop + pipeGapSize, 60, 640 - (pipeGapTop + pipeGapSize));

        await ctx.SetFillStyleAsync("#ffcc00");
        await ctx.FillRectAsync(80, birdY, 34, 24);

        // Debug square to confirm drawing
        await ctx.SetFillStyleAsync("#e91e63");
        await ctx.FillRectAsync(4, 4, 8, 8);

        await ctx.SetFillStyleAsync("#333333");
        await ctx.SetFontAsync("bold 18px system-ui, sans-serif");
        await ctx.FillTextAsync($"Skor: {Score}", 420 - 120, 28);
    }

    private Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (!isRunning) return Task.CompletedTask;
        if (e.Key == " " || e.Code == "Space")
            birdVelocityY = jumpImpulse;
        return Task.CompletedTask;
    }

    private Task HandlePointerDown(PointerEventArgs e)
    {
        if (!isRunning) return Task.CompletedTask;
        birdVelocityY = jumpImpulse;
        return Task.CompletedTask;
    }

    private readonly record struct Rect(double X, double Y, double W, double H)
    {
        public bool Intersects(Rect b)
            => X < b.X + b.W && X + W > b.X && Y < b.Y + b.H && Y + H > b.Y;
    }
}